# BACKEND LEXUSAI COM CHAVES REAIS - CNJ DATAJUD + OPENAI
# Integração completa e funcional

from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
import requests
import os
import json
import sqlite3
from datetime import datetime, timedelta
import hashlib
import openai
from werkzeug.utils import secure_filename
import PyPDF2
import io
import traceback
import time

app = Flask(__name__)
CORS(app, origins=['*'])  # Permitir todas as origens em desenvolvimento

# ====================================================================
# CONFIGURAÇÕES COM SUAS CHAVES REAIS
# ====================================================================

# CNJ DataJud - SUA CHAVE REAL
CNJ_API_KEY = "cDZHYzlZa0JadVREZDJCendQbXY6SkJlTzNjLV9TRENyQk1RdnFKZGRQdw=="
CNJ_BASE_URL = "https://datajud-api.cnj.jus.br"

# OpenAI - SUA CHAVE REAL  
OPENAI_API_KEY = "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"

# Configurar OpenAI
openai.api_key = OPENAI_API_KEY

# Configurações da aplicação
app.config['SECRET_KEY'] = 'lexusai-prod-2024'
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size

# ====================================================================
# CLASSE DE INTEGRAÇÃO CNJ DATAJUD - IMPLEMENTAÇÃO REAL
# ====================================================================

class CNJDataJudIntegration:
    def __init__(self):
        self.api_key = CNJ_API_KEY
        self.base_url = CNJ_BASE_URL
        self.headers = {
            'Authorization': f'APIKey {self.api_key}',
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
        self.timeout = 30
        
    def test_connection(self):
        """Testar conexão com a API CNJ"""
        try:
            url = f"{self.base_url}/api/v1/tribunais"
            response = requests.get(url, headers=self.headers, timeout=self.timeout)
            
            return {
                'success': response.status_code == 200,
                'status_code': response.status_code,
                'message': 'Conexão CNJ OK' if response.status_code == 200 else f'Erro {response.status_code}'
            }
        except Exception as e:
            return {
                'success': False,
                'status_code': 0,
                'message': f'Erro de conexão: {str(e)}'
            }
    
    def buscar_processo_por_numero(self, numero_processo):
        """Buscar processo específico por número"""
        try:
            # Limpar e formatar número do processo
            numero_limpo = ''.join(filter(str.isdigit, numero_processo))
            
            url = f"{self.base_url}/api/v1/processos"
            params = {
                'numeroProcesso': numero_processo,
                'size': 1
            }
            
            response = requests.get(url, headers=self.headers, params=params, timeout=self.timeout)
            
            if response.status_code == 200:
                data = response.json()
                
                if data.get('hits', {}).get('total', {}).get('value', 0) > 0:
                    processo = data['hits']['hits'][0]['_source']
                    return {
                        'success': True,
                        'processo': self._formatar_processo(processo),
                        'fonte': 'CNJ DataJud'
                    }
                else:
                    return {
                        'success': False,
                        'error': 'Processo não encontrado no DataJud',
                        'codigo': 'NOT_FOUND'
                    }
            else:
                return {
                    'success': False,
                    'error': f'Erro na API CNJ: {response.status_code}',
                    'detalhes': response.text
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'Erro na consulta: {str(e)}',
                'trace': traceback.format_exc()
            }
    
    def buscar_jurisprudencia(self, termo_busca, tribunal=None, limite=20):
        """Buscar jurisprudência por termo"""
        try:
            url = f"{self.base_url}/api/v1/decisoes"
            params = {
                'q': termo_busca,
                'size': limite,
                'sort': 'dataJulgamento:desc'
            }
            
            if tribunal:
                params['tribunal'] = tribunal
            
            response = requests.get(url, headers=self.headers, params=params, timeout=self.timeout)
            
            if response.status_code == 200:
                data = response.json()
                decisoes = []
                
                for hit in data.get('hits', {}).get('hits', []):
                    decisao = hit.get('_source', {})
                    decisoes.append(self._formatar_decisao(decisao))
                
                return {
                    'success': True,
                    'decisoes': decisoes,
                    'total': data.get('hits', {}).get('total', {}).get('value', 0),
                    'termo_busca': termo_busca
                }
            else:
                return {
                    'success': False,
                    'error': f'Erro na busca: {response.status_code}',
                    'detalhes': response.text
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'Erro na busca: {str(e)}',
                'trace': traceback.format_exc()
            }
    
    def obter_estatisticas_tribunal(self, tribunal, data_inicio=None, data_fim=None):
        """Obter estatísticas do tribunal"""
        try:
            url = f"{self.base_url}/api/v1/estatisticas"
            params = {
                'tribunal': tribunal
            }
            
            if data_inicio:
                params['dataInicio'] = data_inicio
            if data_fim:
                params['dataFim'] = data_fim
            
            response = requests.get(url, headers=self.headers, params=params, timeout=self.timeout)
            
            if response.status_code == 200:
                return {
                    'success': True,
                    'estatisticas': response.json()
                }
            else:
                return {
                    'success': False,
                    'error': f'Erro nas estatísticas: {response.status_code}'
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'Erro: {str(e)}'
            }
    
    def listar_tribunais(self):
        """Listar todos os tribunais disponíveis"""
        try:
            url = f"{self.base_url}/api/v1/tribunais"
            response = requests.get(url, headers=self.headers, timeout=self.timeout)
            
            if response.status_code == 200:
                return {
                    'success': True,
                    'tribunais': response.json()
                }
            else:
                return {
                    'success': False,
                    'error': f'Erro ao listar tribunais: {response.status_code}'
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'Erro: {str(e)}'
            }
    
    def _formatar_processo(self, processo_raw):
        """Formatar dados do processo para exibição"""
        return {
            'numero': processo_raw.get('numeroProcesso', 'N/A'),
            'classe': processo_raw.get('classe', {}).get('nome', 'N/A'),
            'assunto': processo_raw.get('assunto', {}).get('nome', 'N/A'),
            'tribunal': processo_raw.get('tribunal', 'N/A'),
            'orgaoJulgador': processo_raw.get('orgaoJulgador', {}).get('nome', 'N/A'),
            'dataDistribuicao': processo_raw.get('dataDistribuicao', 'N/A'),
            'situacao': processo_raw.get('situacao', 'N/A'),
            'valor': processo_raw.get('valor', 'N/A'),
            'partes': self._extrair_partes(processo_raw.get('partes', [])),
            'movimentacoes': self._extrair_movimentacoes(processo_raw.get('movimentacoes', []))
        }
    
    def _formatar_decisao(self, decisao_raw):
        """Formatar dados da decisão para exibição"""
        return {
            'id': decisao_raw.get('id', ''),
            'tribunal': decisao_raw.get('tribunal', 'N/A'),
            'relator': decisao_raw.get('relator', 'N/A'),
            'dataJulgamento': decisao_raw.get('dataJulgamento', 'N/A'),
            'ementa': decisao_raw.get('ementa', 'N/A')[:500] + '...' if len(decisao_raw.get('ementa', '')) > 500 else decisao_raw.get('ementa', 'N/A'),
            'classe': decisao_raw.get('classe', 'N/A'),
            'assunto': decisao_raw.get('assunto', 'N/A')
        }
    
    def _extrair_partes(self, partes_raw):
        """Extrair e formatar partes do processo"""
        partes = []
        for parte in partes_raw[:10]:  # Limite de 10 partes
            partes.append({
                'nome': parte.get('nome', 'N/A'),
                'tipo': parte.get('tipo', 'N/A'),
                'documento': parte.get('documento', 'N/A')
            })
        return partes
    
    def _extrair_movimentacoes(self, movimentacoes_raw):
        """Extrair últimas movimentações"""
        movimentacoes = []
        for mov in movimentacoes_raw[:5]:  # Últimas 5 movimentações
            movimentacoes.append({
                'data': mov.get('data', 'N/A'),
                'descricao': mov.get('descricao', 'N/A'),
                'responsavel': mov.get('responsavel', 'N/A')
            })
        return sorted(movimentacoes, key=lambda x: x['data'], reverse=True)

# Instanciar integração CNJ
cnj = CNJDataJudIntegration()

# ====================================================================
# CLASSE DE IA JURÍDICA INTEGRADA COM CNJ
# ====================================================================

class LexusaiIA:
    def __init__(self):
        self.client = openai
        self.cache = {}  # Cache simples para otimização
        
    def consulta_com_datajud(self, pergunta_usuario, contexto_adicional=None):
        """IA integrada com dados CNJ DataJud"""
        try:
            # 1. Extrair termos jurídicos relevantes
            termos = self._extrair_termos_juridicos(pergunta_usuario)
            
            # 2. Buscar dados relevantes no CNJ (se houver termos)
            dados_cnj = []
            if termos:
                for termo in termos[:2]:  # Máximo 2 consultas por pergunta
                    resultado = cnj.buscar_jurisprudencia(termo, limite=5)
                    if resultado['success']:
                        dados_cnj.extend(resultado['decisoes'])
            
            # 3. Construir prompt enriquecido
            prompt_sistema = self._construir_prompt_sistema(dados_cnj, contexto_adicional)
            
            # 4. Gerar resposta com OpenAI
            response = self.client.ChatCompletion.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": prompt_sistema},
                    {"role": "user", "content": pergunta_usuario}
                ],
                max_tokens=1000,
                temperature=0.7,
                timeout=30
            )
            
            resposta = response.choices[0].message.content
            
            # 5. Adicionar informações sobre fontes CNJ
            if dados_cnj:
                resposta += f"\n\n📊 **Baseado em {len(dados_cnj)} decisão(ões) oficial(is) do CNJ DataJud**"
            
            return {
                'success': True,
                'resposta': resposta,
                'fontes_cnj': len(dados_cnj),
                'termos_buscados': termos
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': f'Erro na IA: {str(e)}',
                'trace': traceback.format_exc()
            }
    
    def analisar_documento_com_jurisprudencia(self, texto_documento):
        """Analisar documento legal com jurisprudência CNJ"""
        try:
            # Extrair conceitos jurídicos principais
            conceitos = self._extrair_conceitos_documento(texto_documento)
            
            # Buscar jurisprudência relevante
            jurisprudencia = []
            for conceito in conceitos[:3]:
                resultado = cnj.buscar_jurisprudencia(conceito, limite=3)
                if resultado['success']:
                    jurisprudencia.extend(resultado['decisoes'])
            
            # Análise com IA
            prompt_analise = f"""Analise o documento jurídico abaixo considerando a jurisprudência brasileira recente.

JURISPRUDÊNCIA RELEVANTE (CNJ DataJud):
{json.dumps(jurisprudencia, indent=2, ensure_ascii=False) if jurisprudencia else 'Nenhuma jurisprudência específica encontrada'}

DOCUMENTO A ANALISAR:
{texto_documento[:3000]}

Forneça uma análise estruturada com:
1. RESUMO EXECUTIVO
2. PRINCIPAIS RISCOS JURÍDICOS
3. PONTOS FORTES
4. RECOMENDAÇÕES
5. JURISPRUDÊNCIA APLICÁVEL

Seja preciso e cite sempre que usar dados da jurisprudência CNJ."""

            response = self.client.ChatCompletion.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "Você é um especialista em análise jurídica com acesso aos dados oficiais do CNJ."},
                    {"role": "user", "content": prompt_analise}
                ],
                max_tokens=1500,
                temperature=0.5
            )
            
            return {
                'success': True,
                'analise': response.choices[0].message.content,
                'jurisprudencia_usada': len(jurisprudencia),
                'conceitos_analisados': conceitos
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': f'Erro na análise: {str(e)}'
            }
    
    def _construir_prompt_sistema(self, dados_cnj, contexto_adicional):
        """Construir prompt do sistema com dados CNJ"""
        prompt_base = """Você é a Lexusai, uma IA jurídica especializada em direito brasileiro.
Você tem acesso aos dados oficiais do CNJ via DataJud e deve sempre priorizar informações oficiais.

INSTRUÇÕES:
- Sempre mencione quando usar dados oficiais CNJ
- Seja preciso e técnico, mas acessível
- Cite artigos de lei quando relevante
- Indique quando a resposta é baseada em jurisprudência atual"""

        if dados_cnj:
            prompt_base += f"""

JURISPRUDÊNCIA OFICIAL CNJ DISPONÍVEL:
{json.dumps(dados_cnj, indent=2, ensure_ascii=False)}

Use essas decisões para fundamentar sua resposta quando relevante."""

        if contexto_adicional:
            prompt_base += f"""

CONTEXTO ADICIONAL:
{contexto_adicional}"""

        return prompt_base
    
    def _extrair_termos_juridicos(self, texto):
        """Extrair termos jurídicos para busca no CNJ"""
        termos_juridicos = [
            'responsabilidade civil', 'dano moral', 'indenização', 'lucros cessantes',
            'direito do trabalho', 'rescisão indireta', 'horas extras', 'adicional noturno',
            'direito penal', 'homicídio', 'furto', 'roubo', 'estelionato',
            'direito tributário', 'ICMS', 'ISS', 'IPTU', 'IPI', 'COFINS',
            'direito empresarial', 'falência', 'recuperação judicial', 'dissolução societária',
            'direito civil', 'contrato', 'responsabilidade contratual', 'vício redibitório',
            'direito administrativo', 'licitação', 'concurso público', 'servidor público',
            'direito constitucional', 'habeas corpus', 'mandado de segurança', 'ação direta'
        ]
        
        texto_lower = texto.lower()
        termos_encontrados = []
        
        for termo in termos_juridicos:
            if termo in texto_lower:
                termos_encontrados.append(termo)
        
        return termos_encontrados[:3]
    
    def _extrair_conceitos_documento(self, texto):
        ""
(Content truncated due to size limit. Use page ranges or line ranges to read remaining content)