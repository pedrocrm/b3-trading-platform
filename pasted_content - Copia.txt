# BACKEND LEXUSAI COM CHAVES REAIS - CNJ DATAJUD + OPENAI
# Integra√ß√£o completa e funcional

from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
import requests
import os
import json
import sqlite3
from datetime import datetime, timedelta
import hashlib
import openai
from werkzeug.utils import secure_filename
import PyPDF2
import io
import traceback
import time

app = Flask(__name__)
CORS(app, origins=['*'])  # Permitir todas as origens em desenvolvimento

# ====================================================================
# CONFIGURA√á√ïES COM SUAS CHAVES REAIS
# ====================================================================

# CNJ DataJud - SUA CHAVE REAL
CNJ_API_KEY = "cDZHYzlZa0JadVREZDJCendQbXY6SkJlTzNjLV9TRENyQk1RdnFKZGRQdw=="
CNJ_BASE_URL = "https://datajud-api.cnj.jus.br"

# OpenAI - SUA CHAVE REAL  
OPENAI_API_KEY = "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"

# Configurar OpenAI
openai.api_key = OPENAI_API_KEY

# Configura√ß√µes da aplica√ß√£o
app.config['SECRET_KEY'] = 'lexusai-prod-2024'
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size

# ====================================================================
# CLASSE DE INTEGRA√á√ÉO CNJ DATAJUD - IMPLEMENTA√á√ÉO REAL
# ====================================================================

class CNJDataJudIntegration:
    def __init__(self):
        self.api_key = CNJ_API_KEY
        self.base_url = CNJ_BASE_URL
        self.headers = {
            'Authorization': f'APIKey {self.api_key}',
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
        self.timeout = 30
        
    def test_connection(self):
        """Testar conex√£o com a API CNJ"""
        try:
            url = f"{self.base_url}/api/v1/tribunais"
            response = requests.get(url, headers=self.headers, timeout=self.timeout)
            
            return {
                'success': response.status_code == 200,
                'status_code': response.status_code,
                'message': 'Conex√£o CNJ OK' if response.status_code == 200 else f'Erro {response.status_code}'
            }
        except Exception as e:
            return {
                'success': False,
                'status_code': 0,
                'message': f'Erro de conex√£o: {str(e)}'
            }
    
    def buscar_processo_por_numero(self, numero_processo):
        """Buscar processo espec√≠fico por n√∫mero"""
        try:
            # Limpar e formatar n√∫mero do processo
            numero_limpo = ''.join(filter(str.isdigit, numero_processo))
            
            url = f"{self.base_url}/api/v1/processos"
            params = {
                'numeroProcesso': numero_processo,
                'size': 1
            }
            
            response = requests.get(url, headers=self.headers, params=params, timeout=self.timeout)
            
            if response.status_code == 200:
                data = response.json()
                
                if data.get('hits', {}).get('total', {}).get('value', 0) > 0:
                    processo = data['hits']['hits'][0]['_source']
                    return {
                        'success': True,
                        'processo': self._formatar_processo(processo),
                        'fonte': 'CNJ DataJud'
                    }
                else:
                    return {
                        'success': False,
                        'error': 'Processo n√£o encontrado no DataJud',
                        'codigo': 'NOT_FOUND'
                    }
            else:
                return {
                    'success': False,
                    'error': f'Erro na API CNJ: {response.status_code}',
                    'detalhes': response.text
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'Erro na consulta: {str(e)}',
                'trace': traceback.format_exc()
            }
    
    def buscar_jurisprudencia(self, termo_busca, tribunal=None, limite=20):
        """Buscar jurisprud√™ncia por termo"""
        try:
            url = f"{self.base_url}/api/v1/decisoes"
            params = {
                'q': termo_busca,
                'size': limite,
                'sort': 'dataJulgamento:desc'
            }
            
            if tribunal:
                params['tribunal'] = tribunal
            
            response = requests.get(url, headers=self.headers, params=params, timeout=self.timeout)
            
            if response.status_code == 200:
                data = response.json()
                decisoes = []
                
                for hit in data.get('hits', {}).get('hits', []):
                    decisao = hit.get('_source', {})
                    decisoes.append(self._formatar_decisao(decisao))
                
                return {
                    'success': True,
                    'decisoes': decisoes,
                    'total': data.get('hits', {}).get('total', {}).get('value', 0),
                    'termo_busca': termo_busca
                }
            else:
                return {
                    'success': False,
                    'error': f'Erro na busca: {response.status_code}',
                    'detalhes': response.text
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'Erro na busca: {str(e)}',
                'trace': traceback.format_exc()
            }
    
    def obter_estatisticas_tribunal(self, tribunal, data_inicio=None, data_fim=None):
        """Obter estat√≠sticas do tribunal"""
        try:
            url = f"{self.base_url}/api/v1/estatisticas"
            params = {
                'tribunal': tribunal
            }
            
            if data_inicio:
                params['dataInicio'] = data_inicio
            if data_fim:
                params['dataFim'] = data_fim
            
            response = requests.get(url, headers=self.headers, params=params, timeout=self.timeout)
            
            if response.status_code == 200:
                return {
                    'success': True,
                    'estatisticas': response.json()
                }
            else:
                return {
                    'success': False,
                    'error': f'Erro nas estat√≠sticas: {response.status_code}'
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'Erro: {str(e)}'
            }
    
    def listar_tribunais(self):
        """Listar todos os tribunais dispon√≠veis"""
        try:
            url = f"{self.base_url}/api/v1/tribunais"
            response = requests.get(url, headers=self.headers, timeout=self.timeout)
            
            if response.status_code == 200:
                return {
                    'success': True,
                    'tribunais': response.json()
                }
            else:
                return {
                    'success': False,
                    'error': f'Erro ao listar tribunais: {response.status_code}'
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'Erro: {str(e)}'
            }
    
    def _formatar_processo(self, processo_raw):
        """Formatar dados do processo para exibi√ß√£o"""
        return {
            'numero': processo_raw.get('numeroProcesso', 'N/A'),
            'classe': processo_raw.get('classe', {}).get('nome', 'N/A'),
            'assunto': processo_raw.get('assunto', {}).get('nome', 'N/A'),
            'tribunal': processo_raw.get('tribunal', 'N/A'),
            'orgaoJulgador': processo_raw.get('orgaoJulgador', {}).get('nome', 'N/A'),
            'dataDistribuicao': processo_raw.get('dataDistribuicao', 'N/A'),
            'situacao': processo_raw.get('situacao', 'N/A'),
            'valor': processo_raw.get('valor', 'N/A'),
            'partes': self._extrair_partes(processo_raw.get('partes', [])),
            'movimentacoes': self._extrair_movimentacoes(processo_raw.get('movimentacoes', []))
        }
    
    def _formatar_decisao(self, decisao_raw):
        """Formatar dados da decis√£o para exibi√ß√£o"""
        return {
            'id': decisao_raw.get('id', ''),
            'tribunal': decisao_raw.get('tribunal', 'N/A'),
            'relator': decisao_raw.get('relator', 'N/A'),
            'dataJulgamento': decisao_raw.get('dataJulgamento', 'N/A'),
            'ementa': decisao_raw.get('ementa', 'N/A')[:500] + '...' if len(decisao_raw.get('ementa', '')) > 500 else decisao_raw.get('ementa', 'N/A'),
            'classe': decisao_raw.get('classe', 'N/A'),
            'assunto': decisao_raw.get('assunto', 'N/A')
        }
    
    def _extrair_partes(self, partes_raw):
        """Extrair e formatar partes do processo"""
        partes = []
        for parte in partes_raw[:10]:  # Limite de 10 partes
            partes.append({
                'nome': parte.get('nome', 'N/A'),
                'tipo': parte.get('tipo', 'N/A'),
                'documento': parte.get('documento', 'N/A')
            })
        return partes
    
    def _extrair_movimentacoes(self, movimentacoes_raw):
        """Extrair √∫ltimas movimenta√ß√µes"""
        movimentacoes = []
        for mov in movimentacoes_raw[:5]:  # √öltimas 5 movimenta√ß√µes
            movimentacoes.append({
                'data': mov.get('data', 'N/A'),
                'descricao': mov.get('descricao', 'N/A'),
                'responsavel': mov.get('responsavel', 'N/A')
            })
        return sorted(movimentacoes, key=lambda x: x['data'], reverse=True)

# Instanciar integra√ß√£o CNJ
cnj = CNJDataJudIntegration()

# ====================================================================
# CLASSE DE IA JUR√çDICA INTEGRADA COM CNJ
# ====================================================================

class LexusaiIA:
    def __init__(self):
        self.client = openai
        self.cache = {}  # Cache simples para otimiza√ß√£o
        
    def consulta_com_datajud(self, pergunta_usuario, contexto_adicional=None):
        """IA integrada com dados CNJ DataJud"""
        try:
            # 1. Extrair termos jur√≠dicos relevantes
            termos = self._extrair_termos_juridicos(pergunta_usuario)
            
            # 2. Buscar dados relevantes no CNJ (se houver termos)
            dados_cnj = []
            if termos:
                for termo in termos[:2]:  # M√°ximo 2 consultas por pergunta
                    resultado = cnj.buscar_jurisprudencia(termo, limite=5)
                    if resultado['success']:
                        dados_cnj.extend(resultado['decisoes'])
            
            # 3. Construir prompt enriquecido
            prompt_sistema = self._construir_prompt_sistema(dados_cnj, contexto_adicional)
            
            # 4. Gerar resposta com OpenAI
            response = self.client.ChatCompletion.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": prompt_sistema},
                    {"role": "user", "content": pergunta_usuario}
                ],
                max_tokens=1000,
                temperature=0.7,
                timeout=30
            )
            
            resposta = response.choices[0].message.content
            
            # 5. Adicionar informa√ß√µes sobre fontes CNJ
            if dados_cnj:
                resposta += f"\n\nüìä **Baseado em {len(dados_cnj)} decis√£o(√µes) oficial(is) do CNJ DataJud**"
            
            return {
                'success': True,
                'resposta': resposta,
                'fontes_cnj': len(dados_cnj),
                'termos_buscados': termos
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': f'Erro na IA: {str(e)}',
                'trace': traceback.format_exc()
            }
    
    def analisar_documento_com_jurisprudencia(self, texto_documento):
        """Analisar documento legal com jurisprud√™ncia CNJ"""
        try:
            # Extrair conceitos jur√≠dicos principais
            conceitos = self._extrair_conceitos_documento(texto_documento)
            
            # Buscar jurisprud√™ncia relevante
            jurisprudencia = []
            for conceito in conceitos[:3]:
                resultado = cnj.buscar_jurisprudencia(conceito, limite=3)
                if resultado['success']:
                    jurisprudencia.extend(resultado['decisoes'])
            
            # An√°lise com IA
            prompt_analise = f"""Analise o documento jur√≠dico abaixo considerando a jurisprud√™ncia brasileira recente.

JURISPRUD√äNCIA RELEVANTE (CNJ DataJud):
{json.dumps(jurisprudencia, indent=2, ensure_ascii=False) if jurisprudencia else 'Nenhuma jurisprud√™ncia espec√≠fica encontrada'}

DOCUMENTO A ANALISAR:
{texto_documento[:3000]}

Forne√ßa uma an√°lise estruturada com:
1. RESUMO EXECUTIVO
2. PRINCIPAIS RISCOS JUR√çDICOS
3. PONTOS FORTES
4. RECOMENDA√á√ïES
5. JURISPRUD√äNCIA APLIC√ÅVEL

Seja preciso e cite sempre que usar dados da jurisprud√™ncia CNJ."""

            response = self.client.ChatCompletion.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "Voc√™ √© um especialista em an√°lise jur√≠dica com acesso aos dados oficiais do CNJ."},
                    {"role": "user", "content": prompt_analise}
                ],
                max_tokens=1500,
                temperature=0.5
            )
            
            return {
                'success': True,
                'analise': response.choices[0].message.content,
                'jurisprudencia_usada': len(jurisprudencia),
                'conceitos_analisados': conceitos
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': f'Erro na an√°lise: {str(e)}'
            }
    
    def _construir_prompt_sistema(self, dados_cnj, contexto_adicional):
        """Construir prompt do sistema com dados CNJ"""
        prompt_base = """Voc√™ √© a Lexusai, uma IA jur√≠dica especializada em direito brasileiro.
Voc√™ tem acesso aos dados oficiais do CNJ via DataJud e deve sempre priorizar informa√ß√µes oficiais.

INSTRU√á√ïES:
- Sempre mencione quando usar dados oficiais CNJ
- Seja preciso e t√©cnico, mas acess√≠vel
- Cite artigos de lei quando relevante
- Indique quando a resposta √© baseada em jurisprud√™ncia atual"""

        if dados_cnj:
            prompt_base += f"""

JURISPRUD√äNCIA OFICIAL CNJ DISPON√çVEL:
{json.dumps(dados_cnj, indent=2, ensure_ascii=False)}

Use essas decis√µes para fundamentar sua resposta quando relevante."""

        if contexto_adicional:
            prompt_base += f"""

CONTEXTO ADICIONAL:
{contexto_adicional}"""

        return prompt_base
    
    def _extrair_termos_juridicos(self, texto):
        """Extrair termos jur√≠dicos para busca no CNJ"""
        termos_juridicos = [
            'responsabilidade civil', 'dano moral', 'indeniza√ß√£o', 'lucros cessantes',
            'direito do trabalho', 'rescis√£o indireta', 'horas extras', 'adicional noturno',
            'direito penal', 'homic√≠dio', 'furto', 'roubo', 'estelionato',
            'direito tribut√°rio', 'ICMS', 'ISS', 'IPTU', 'IPI', 'COFINS',
            'direito empresarial', 'fal√™ncia', 'recupera√ß√£o judicial', 'dissolu√ß√£o societ√°ria',
            'direito civil', 'contrato', 'responsabilidade contratual', 'v√≠cio redibit√≥rio',
            'direito administrativo', 'licita√ß√£o', 'concurso p√∫blico', 'servidor p√∫blico',
            'direito constitucional', 'habeas corpus', 'mandado de seguran√ßa', 'a√ß√£o direta'
        ]
        
        texto_lower = texto.lower()
        termos_encontrados = []
        
        for termo in termos_juridicos:
            if termo in texto_lower:
                termos_encontrados.append(termo)
        
        return termos_encontrados[:3]
    
    def _extrair_conceitos_documento(self, texto):
        ""
(Content truncated due to size limit. Use page ranges or line ranges to read remaining content)